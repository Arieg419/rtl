{"ast":null,"code":"import _toConsumableArray from \"/Users/omergoldberg/dev/rtl/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _assertThisInitialized from \"/Users/omergoldberg/dev/rtl/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _classCallCheck from \"/Users/omergoldberg/dev/rtl/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/omergoldberg/dev/rtl/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/omergoldberg/dev/rtl/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"/Users/omergoldberg/dev/rtl/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/omergoldberg/dev/rtl/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n/* eslint-disable react/no-multi-comp */\n\n\nimport * as React from 'react';\nimport { View, Animated, TouchableWithoutFeedback, StyleSheet, Platform, Keyboard } from 'react-native';\nimport SafeAreaView from 'react-native-safe-area-view';\nimport color from 'color';\nimport overlay from '../styles/overlay';\nimport Icon from './Icon';\nimport Surface from './Surface';\nimport Badge from './Badge';\nimport TouchableRipple from './TouchableRipple';\nimport Text from './Typography/Text';\nimport { black, white } from '../styles/colors';\nimport { withTheme } from '../core/theming';\nvar MIN_RIPPLE_SCALE = 0.001; // Minimum scale is not 0 due to bug with animation\n\nvar MIN_TAB_WIDTH = 96;\nvar MAX_TAB_WIDTH = 168;\nvar BAR_HEIGHT = 56;\nvar FAR_FAR_AWAY = 9999;\n\nvar Touchable = function Touchable(_ref) {\n  var _0 = _ref.route,\n      style = _ref.style,\n      children = _ref.children,\n      borderless = _ref.borderless,\n      centered = _ref.centered,\n      rippleColor = _ref.rippleColor,\n      rest = _objectWithoutProperties(_ref, [\"route\", \"style\", \"children\", \"borderless\", \"centered\", \"rippleColor\"]);\n\n  return TouchableRipple.supported ? /*#__PURE__*/React.createElement(TouchableRipple, _extends({}, rest, {\n    borderless: borderless,\n    centered: centered,\n    rippleColor: rippleColor,\n    style: style\n  }), children) : /*#__PURE__*/React.createElement(TouchableWithoutFeedback, rest, /*#__PURE__*/React.createElement(View, {\n    style: style\n  }, children));\n};\n\nvar SceneComponent = /*#__PURE__*/function (_React$PureComponent) {\n  _inherits(SceneComponent, _React$PureComponent);\n\n  var _super = _createSuper(SceneComponent);\n\n  function SceneComponent() {\n    _classCallCheck(this, SceneComponent);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(SceneComponent, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          component = _this$props.component,\n          rest = _objectWithoutProperties(_this$props, [\"component\"]);\n\n      return /*#__PURE__*/React.createElement(component, rest);\n    }\n  }]);\n\n  return SceneComponent;\n}(React.PureComponent);\n/**\n * Bottom navigation provides quick navigation between top-level views of an app with a bottom navigation bar.\n * It is primarily designed for use on mobile.\n *\n * For integration with React Navigation, you can use [react-navigation-material-bottom-tab-navigator](https://github.com/react-navigation/react-navigation-material-bottom-tab-navigator).\n *\n * By default Bottom navigation uses primary color as a background, in dark theme with `adaptive` mode it will use surface colour instead.\n * See [Dark Theme](https://callstack.github.io/react-native-paper/theming.html#dark-theme) for more informations\n *\n * <div class=\"screenshots\">\n *   <img class=\"medium\" src=\"screenshots/bottom-navigation.gif\" />\n * </div>\n *\n * ## Usage\n * ```js\n * import * as React from 'react';\n * import { BottomNavigation, Text } from 'react-native-paper';\n *\n * const MusicRoute = () => <Text>Music</Text>;\n *\n * const AlbumsRoute = () => <Text>Albums</Text>;\n *\n * const RecentsRoute = () => <Text>Recents</Text>;\n *\n * const MyComponent = () => {\n *   const [index, setIndex] = React.useState(0);\n *   const [routes] = React.useState([\n *     { key: 'music', title: 'Music', icon: 'queue-music' },\n *     { key: 'albums', title: 'Albums', icon: 'album' },\n *     { key: 'recents', title: 'Recents', icon: 'history' },\n *   ]);\n *\n *   const renderScene = BottomNavigation.SceneMap({\n *     music: MusicRoute,\n *     albums: AlbumsRoute,\n *     recents: RecentsRoute,\n *   });\n *\n *   return (\n *     <BottomNavigation\n *       navigationState={{ index, routes }}\n *       onIndexChange={setIndex}\n *       renderScene={renderScene}\n *     />\n *   );\n * };\n *\n * export default MyComponent;\n * ```\n */\n\n\nvar BottomNavigation = /*#__PURE__*/function (_React$Component) {\n  _inherits(BottomNavigation, _React$Component);\n\n  var _super2 = _createSuper(BottomNavigation);\n\n  _createClass(BottomNavigation, null, [{\n    key: \"SceneMap\",\n\n    /**\n     * Function which takes a map of route keys to components.\n     * Pure components are used to minmize re-rendering of the pages.\n     * This drastically improves the animation performance.\n     */\n    value: function SceneMap(scenes) {\n      return function (_ref2) {\n        var route = _ref2.route,\n            jumpTo = _ref2.jumpTo;\n        return /*#__PURE__*/React.createElement(SceneComponent, {\n          key: route.key,\n          component: scenes[route.key ? route.key : ''],\n          route: route,\n          jumpTo: jumpTo\n        });\n      };\n    }\n  }, {\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      var _nextProps$navigation = nextProps.navigationState,\n          index = _nextProps$navigation.index,\n          routes = _nextProps$navigation.routes; // Re-create animated values if routes have been added/removed\n      // Preserve previous animated values if they exist, so we don't break animations\n\n      var tabs = routes.map( // focused === 1, unfocused === 0\n      function (_, i) {\n        return prevState.tabs[i] || new Animated.Value(i === index ? 1 : 0);\n      });\n      var offsets = routes.map( // offscreen === 1, normal === 0\n      function (_, i) {\n        return prevState.offsets[i] || new Animated.Value(i === index ? 0 : 1);\n      });\n      var nextState = {\n        tabs: tabs,\n        offsets: offsets\n      };\n\n      if (index !== prevState.current) {\n        /* $FlowFixMe */\n        Object.assign(nextState, {\n          // Store the current index in state so that we can later check if the index has changed\n          current: index,\n          previous: prevState.current,\n          // Set the current tab to be loaded if it was not loaded before\n          loaded: prevState.loaded.includes(index) ? prevState.loaded : [].concat(_toConsumableArray(prevState.loaded), [index])\n        });\n      }\n\n      return nextState;\n    }\n  }]);\n\n  function BottomNavigation(props) {\n    var _this;\n\n    _classCallCheck(this, BottomNavigation);\n\n    _this = _super2.call(this, props);\n\n    _defineProperty(_assertThisInitialized(_this), \"handleKeyboardShow\", function () {\n      var scale = _this.props.theme.animation.scale;\n\n      _this.setState({\n        keyboard: true\n      }, function () {\n        return Animated.timing(_this.state.visible, {\n          toValue: 0,\n          duration: 150 * scale,\n          useNativeDriver: true\n        }).start();\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleKeyboardHide\", function () {\n      var scale = _this.props.theme.animation.scale;\n      Animated.timing(_this.state.visible, {\n        toValue: 1,\n        duration: 100 * scale,\n        useNativeDriver: true\n      }).start(function () {\n        _this.setState({\n          keyboard: false\n        });\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"animateToCurrentIndex\", function () {\n      var shifting = _this.isShifting();\n\n      var _this$props2 = _this.props,\n          navigationState = _this$props2.navigationState,\n          scale = _this$props2.theme.animation.scale;\n      var routes = navigationState.routes,\n          index = navigationState.index; // Reset the ripple to avoid glitch if it's currently animating\n\n      _this.state.ripple.setValue(MIN_RIPPLE_SCALE);\n\n      Animated.parallel([Animated.timing(_this.state.ripple, {\n        toValue: 1,\n        duration: shifting ? 400 * scale : 0,\n        useNativeDriver: true\n      })].concat(_toConsumableArray(routes.map(function (_, i) {\n        return Animated.timing(_this.state.tabs[i], {\n          toValue: i === index ? 1 : 0,\n          duration: shifting ? 150 * scale : 0,\n          useNativeDriver: true\n        });\n      })))).start(function (_ref3) {\n        var finished = _ref3.finished;\n\n        // Workaround a bug in native animations where this is reset after first animation\n        _this.state.tabs.map(function (tab, i) {\n          return tab.setValue(i === index ? 1 : 0);\n        }); // Update the index to change bar's bacground color and then hide the ripple\n\n\n        _this.state.index.setValue(index);\n\n        _this.state.ripple.setValue(MIN_RIPPLE_SCALE);\n\n        if (finished) {\n          // Position all inactive screens offscreen to save memory usage\n          // Only do it when animation has finished to avoid glitches mid-transition if switching fast\n          _this.state.offsets.forEach(function (offset, i) {\n            if (i === index) {\n              offset.setValue(0);\n            } else {\n              offset.setValue(1);\n            }\n          });\n        }\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleLayout\", function (e) {\n      var layout = _this.state.layout;\n      var _e$nativeEvent$layout = e.nativeEvent.layout,\n          height = _e$nativeEvent$layout.height,\n          width = _e$nativeEvent$layout.width;\n\n      if (height === layout.height && width === layout.width) {\n        return;\n      }\n\n      _this.setState({\n        layout: {\n          height: height,\n          width: width,\n          measured: true\n        }\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleTabPress\", function (index) {\n      var _this$props3 = _this.props,\n          navigationState = _this$props3.navigationState,\n          onTabPress = _this$props3.onTabPress,\n          onIndexChange = _this$props3.onIndexChange;\n      var event = {\n        route: navigationState.routes[index],\n        defaultPrevented: false,\n        preventDefault: function preventDefault() {\n          event.defaultPrevented = true;\n        }\n      };\n      onTabPress === null || onTabPress === void 0 ? void 0 : onTabPress(event);\n\n      if (event.defaultPrevented) {\n        return;\n      }\n\n      if (index !== navigationState.index) {\n        onIndexChange(index);\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"jumpTo\", function (key) {\n      var index = _this.props.navigationState.routes.findIndex(function (route) {\n        return route.key === key;\n      });\n\n      _this.props.onIndexChange(index);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"isShifting\", function () {\n      return typeof _this.props.shifting === 'boolean' ? _this.props.shifting : _this.props.navigationState.routes.length > 3;\n    });\n\n    var _index = _this.props.navigationState.index;\n    _this.state = {\n      visible: new Animated.Value(1),\n      tabs: [],\n      offsets: [],\n      index: new Animated.Value(_index),\n      ripple: new Animated.Value(MIN_RIPPLE_SCALE),\n      touch: new Animated.Value(MIN_RIPPLE_SCALE),\n      layout: {\n        height: 0,\n        width: 0,\n        measured: false\n      },\n      current: _index,\n      previous: 0,\n      loaded: [_index],\n      keyboard: false\n    };\n    return _this;\n  }\n\n  _createClass(BottomNavigation, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      // Workaround for native animated bug in react-native@^0.57\n      // Context: https://github.com/callstack/react-native-paper/pull/637\n      this.animateToCurrentIndex();\n\n      if (Platform.OS === 'ios') {\n        Keyboard.addListener('keyboardWillShow', this.handleKeyboardShow);\n        Keyboard.addListener('keyboardWillHide', this.handleKeyboardHide);\n      } else {\n        Keyboard.addListener('keyboardDidShow', this.handleKeyboardShow);\n        Keyboard.addListener('keyboardDidHide', this.handleKeyboardHide);\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var _this2 = this;\n\n      if (prevProps.navigationState.index === this.props.navigationState.index) {\n        return;\n      } // Reset offsets of previous and current tabs before animation\n\n\n      this.state.offsets.forEach(function (offset, i) {\n        if (i === _this2.props.navigationState.index || i === prevProps.navigationState.index) {\n          offset.setValue(0);\n        }\n      });\n      this.animateToCurrentIndex();\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (Platform.OS === 'ios') {\n        Keyboard.removeListener('keyboardWillShow', this.handleKeyboardShow);\n        Keyboard.removeListener('keyboardWillHide', this.handleKeyboardHide);\n      } else {\n        Keyboard.removeListener('keyboardDidShow', this.handleKeyboardShow);\n        Keyboard.removeListener('keyboardDidHide', this.handleKeyboardHide);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n\n      var _this$props4 = this.props,\n          navigationState = _this$props4.navigationState,\n          renderScene = _this$props4.renderScene,\n          renderIcon = _this$props4.renderIcon,\n          renderLabel = _this$props4.renderLabel,\n          _this$props4$renderTo = _this$props4.renderTouchable,\n          renderTouchable = _this$props4$renderTo === void 0 ? function (props) {\n        return /*#__PURE__*/React.createElement(Touchable, props);\n      } : _this$props4$renderTo,\n          _this$props4$getLabel = _this$props4.getLabelText,\n          getLabelText = _this$props4$getLabel === void 0 ? function (_ref4) {\n        var route = _ref4.route;\n        return route.title;\n      } : _this$props4$getLabel,\n          _this$props4$getBadge = _this$props4.getBadge,\n          getBadge = _this$props4$getBadge === void 0 ? function (_ref5) {\n        var route = _ref5.route;\n        return route.badge;\n      } : _this$props4$getBadge,\n          _this$props4$getColor = _this$props4.getColor,\n          getColor = _this$props4$getColor === void 0 ? function (_ref6) {\n        var route = _ref6.route;\n        return route.color;\n      } : _this$props4$getColor,\n          _this$props4$getAcces = _this$props4.getAccessibilityLabel,\n          getAccessibilityLabel = _this$props4$getAcces === void 0 ? function (_ref7) {\n        var route = _ref7.route;\n        return route.accessibilityLabel;\n      } : _this$props4$getAcces,\n          _this$props4$getTestI = _this$props4.getTestID,\n          getTestID = _this$props4$getTestI === void 0 ? function (_ref8) {\n        var route = _ref8.route;\n        return route.testID;\n      } : _this$props4$getTestI,\n          activeColor = _this$props4.activeColor,\n          inactiveColor = _this$props4.inactiveColor,\n          keyboardHidesNavigationBar = _this$props4.keyboardHidesNavigationBar,\n          barStyle = _this$props4.barStyle,\n          labeled = _this$props4.labeled,\n          style = _this$props4.style,\n          theme = _this$props4.theme,\n          sceneAnimationEnabled = _this$props4.sceneAnimationEnabled;\n      var _this$state = this.state,\n          layout = _this$state.layout,\n          loaded = _this$state.loaded,\n          index = _this$state.index,\n          visible = _this$state.visible,\n          ripple = _this$state.ripple,\n          keyboard = _this$state.keyboard,\n          tabs = _this$state.tabs,\n          offsets = _this$state.offsets;\n      var routes = navigationState.routes;\n      var colors = theme.colors,\n          isDarkTheme = theme.dark,\n          mode = theme.mode;\n      var shifting = this.isShifting();\n\n      var _ref9 = StyleSheet.flatten(barStyle) || {},\n          customBackground = _ref9.backgroundColor,\n          _ref9$elevation = _ref9.elevation,\n          elevation = _ref9$elevation === void 0 ? 4 : _ref9$elevation;\n\n      var approxBackgroundColor = customBackground ? customBackground : isDarkTheme && mode === 'adaptive' ? overlay(elevation, colors.surface) : colors.primary;\n      var backgroundColor = shifting ? index.interpolate({\n        inputRange: routes.map(function (_, i) {\n          return i;\n        }),\n        //@ts-ignore\n        outputRange: routes.map(function (route) {\n          return getColor({\n            route: route\n          }) || approxBackgroundColor;\n        })\n      }) : approxBackgroundColor;\n      var isDark = !color(approxBackgroundColor).isLight();\n      var textColor = isDark ? white : black;\n      var activeTintColor = typeof activeColor !== 'undefined' ? activeColor : textColor;\n      var inactiveTintColor = typeof inactiveColor !== 'undefined' ? inactiveColor : color(textColor).alpha(0.5).rgb().string();\n      var touchColor = color(activeColor || activeTintColor).alpha(0.12).rgb().string();\n      var maxTabWidth = routes.length > 3 ? MIN_TAB_WIDTH : MAX_TAB_WIDTH;\n      var maxTabBarWidth = maxTabWidth * routes.length;\n      var tabBarWidth = Math.min(layout.width, maxTabBarWidth);\n      var tabWidth = tabBarWidth / routes.length;\n      var rippleSize = layout.width / 4;\n      return /*#__PURE__*/React.createElement(View, {\n        style: [styles.container, style]\n      }, /*#__PURE__*/React.createElement(View, {\n        style: [styles.content, {\n          backgroundColor: colors.background\n        }]\n      }, routes.map(function (route, index) {\n        if (!loaded.includes(index)) {\n          // Don't render a screen if we've never navigated to it\n          return null;\n        }\n\n        var focused = navigationState.index === index;\n        var opacity = sceneAnimationEnabled ? tabs[index] : focused ? 1 : 0;\n        var top = offsets[index].interpolate({\n          inputRange: [0, 1],\n          outputRange: [0, FAR_FAR_AWAY]\n        });\n        return /*#__PURE__*/React.createElement(Animated.View, {\n          key: route.key,\n          pointerEvents: focused ? 'auto' : 'none',\n          accessibilityElementsHidden: !focused,\n          importantForAccessibility: focused ? 'auto' : 'no-hide-descendants',\n          style: [StyleSheet.absoluteFill, {\n            opacity: opacity\n          }],\n          collapsable: false,\n          removeClippedSubviews: // On iOS, set removeClippedSubviews to true only when not focused\n          // This is an workaround for a bug where the clipped view never re-appears\n          Platform.OS === 'ios' ? navigationState.index !== index : true\n        }, /*#__PURE__*/React.createElement(Animated.View, {\n          style: [styles.content, {\n            top: top\n          }]\n        }, renderScene({\n          route: route,\n          jumpTo: _this3.jumpTo\n        })));\n      })), /*#__PURE__*/React.createElement(Surface, {\n        style: [styles.bar, keyboardHidesNavigationBar ? {\n          // When the keyboard is shown, slide down the navigation bar\n          transform: [{\n            translateY: visible.interpolate({\n              inputRange: [0, 1],\n              outputRange: [layout.height, 0]\n            })\n          }],\n          // Absolutely position the navigation bar so that the content is below it\n          // This is needed to avoid gap at bottom when the navigation bar is hidden\n          position: keyboard ? 'absolute' : null\n        } : null, barStyle],\n        pointerEvents: layout.measured ? keyboardHidesNavigationBar && keyboard ? 'none' : 'auto' : 'none',\n        onLayout: this.handleLayout\n      }, /*#__PURE__*/React.createElement(Animated.View, {\n        style: [styles.barContent, {\n          backgroundColor: backgroundColor\n        }]\n      }, /*#__PURE__*/React.createElement(SafeAreaView, {\n        forceInset: {\n          top: 'never',\n          bottom: 'always'\n        },\n        style: [styles.items, {\n          maxWidth: maxTabBarWidth\n        }]\n      }, shifting ? /*#__PURE__*/React.createElement(Animated.View, {\n        pointerEvents: \"none\",\n        style: [styles.ripple, {\n          // Since we have a single ripple, we have to reposition it so that it appears to expand from active tab.\n          // We need to move it from the top to center of the navigation bar and from the left to the active tab.\n          top: (BAR_HEIGHT - rippleSize) / 2,\n          left: tabWidth * (navigationState.index + 0.5) - rippleSize / 2,\n          height: rippleSize,\n          width: rippleSize,\n          borderRadius: rippleSize / 2,\n          backgroundColor: getColor({\n            route: routes[navigationState.index]\n          }),\n          transform: [{\n            // Scale to twice the size  to ensure it covers the whole navigation bar\n            scale: ripple.interpolate({\n              inputRange: [0, 1],\n              outputRange: [0, 8]\n            })\n          }],\n          opacity: ripple.interpolate({\n            inputRange: [0, MIN_RIPPLE_SCALE, 0.3, 1],\n            outputRange: [0, 0, 1, 1]\n          })\n        }]\n      }) : null, routes.map(function (route, index) {\n        var focused = navigationState.index === index;\n        var active = tabs[index]; // Scale the label up\n\n        var scale = labeled && shifting ? active.interpolate({\n          inputRange: [0, 1],\n          outputRange: [0.5, 1]\n        }) : 1; // Move down the icon to account for no-label in shifting and smaller label in non-shifting.\n\n        var translateY = labeled ? shifting ? active.interpolate({\n          inputRange: [0, 1],\n          outputRange: [7, 0]\n        }) : 0 : 7; // We render the active icon and label on top of inactive ones and cross-fade them on change.\n        // This trick gives the illusion that we are animating between active and inactive colors.\n        // This is to ensure that we can use native driver, as colors cannot be animated with native driver.\n\n        var activeOpacity = active;\n        var inactiveOpacity = active.interpolate({\n          inputRange: [0, 1],\n          outputRange: [1, 0]\n        });\n        var badge = getBadge({\n          route: route\n        });\n        return renderTouchable({\n          key: route.key,\n          route: route,\n          borderless: true,\n          centered: true,\n          rippleColor: touchColor,\n          onPress: function onPress() {\n            return _this3.handleTabPress(index);\n          },\n          testID: getTestID({\n            route: route\n          }),\n          accessibilityLabel: getAccessibilityLabel({\n            route: route\n          }),\n          accessibilityTraits: focused ? ['button', 'selected'] : 'button',\n          accessibilityComponentType: 'button',\n          accessibilityRole: 'button',\n          accessibilityState: {\n            selected: true\n          },\n          style: styles.item,\n          children: /*#__PURE__*/React.createElement(View, {\n            pointerEvents: \"none\"\n          }, /*#__PURE__*/React.createElement(Animated.View, {\n            style: [styles.iconContainer, {\n              transform: [{\n                translateY: translateY\n              }]\n            }]\n          }, /*#__PURE__*/React.createElement(Animated.View, {\n            style: [styles.iconWrapper, {\n              opacity: activeOpacity\n            }]\n          }, renderIcon ? renderIcon({\n            route: route,\n            focused: true,\n            color: activeTintColor\n          }) : /*#__PURE__*/React.createElement(Icon, {\n            source: route.icon,\n            color: activeTintColor,\n            size: 24\n          })), /*#__PURE__*/React.createElement(Animated.View, {\n            style: [styles.iconWrapper, {\n              opacity: inactiveOpacity\n            }]\n          }, renderIcon ? renderIcon({\n            route: route,\n            focused: false,\n            color: inactiveTintColor\n          }) : /*#__PURE__*/React.createElement(Icon, {\n            source: route.icon,\n            color: inactiveTintColor,\n            size: 24\n          })), /*#__PURE__*/React.createElement(View, {\n            style: [styles.badgeContainer, {\n              right: (badge != null && typeof badge !== 'boolean' ? String(badge).length * -2 : 0) - 2\n            }]\n          }, typeof badge === 'boolean' ? /*#__PURE__*/React.createElement(Badge, {\n            visible: badge,\n            size: 8\n          }) : /*#__PURE__*/React.createElement(Badge, {\n            visible: badge != null,\n            size: 16\n          }, badge))), labeled ? /*#__PURE__*/React.createElement(Animated.View, {\n            style: [styles.labelContainer, {\n              transform: [{\n                scale: scale\n              }]\n            }]\n          }, /*#__PURE__*/React.createElement(Animated.View, {\n            style: [styles.labelWrapper, {\n              opacity: activeOpacity\n            }]\n          }, renderLabel ? renderLabel({\n            route: route,\n            focused: true,\n            color: activeTintColor\n          }) : /*#__PURE__*/React.createElement(Text, {\n            style: [styles.label, {\n              color: activeTintColor\n            }]\n          }, getLabelText({\n            route: route\n          }))), shifting ? null : /*#__PURE__*/React.createElement(Animated.View, {\n            style: [styles.labelWrapper, {\n              opacity: inactiveOpacity\n            }]\n          }, renderLabel ? renderLabel({\n            route: route,\n            focused: false,\n            color: inactiveTintColor\n          }) : /*#__PURE__*/React.createElement(Text, {\n            style: [styles.label, {\n              color: inactiveTintColor\n            }]\n          }, getLabelText({\n            route: route\n          })))) : /*#__PURE__*/React.createElement(View, {\n            style: styles.labelContainer\n          }))\n        });\n      })))));\n    }\n  }]);\n\n  return BottomNavigation;\n}(React.Component);\n\n_defineProperty(BottomNavigation, \"defaultProps\", {\n  labeled: true,\n  keyboardHidesNavigationBar: true,\n  sceneAnimationEnabled: false\n});\n\nexport default withTheme(BottomNavigation);\nvar styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    overflow: 'hidden'\n  },\n  content: {\n    flex: 1\n  },\n  bar: {\n    left: 0,\n    right: 0,\n    bottom: 0,\n    elevation: 4\n  },\n  barContent: {\n    alignItems: 'center',\n    overflow: 'hidden'\n  },\n  items: {\n    flexDirection: 'row',\n    width: '100%'\n  },\n  item: {\n    flex: 1,\n    // Top padding is 6 and bottom padding is 10\n    // The extra 4dp bottom padding is offset by label's height\n    paddingVertical: 6\n  },\n  ripple: {\n    position: 'absolute'\n  },\n  iconContainer: {\n    height: 24,\n    width: 24,\n    marginTop: 2,\n    marginHorizontal: 12,\n    alignSelf: 'center'\n  },\n  iconWrapper: _objectSpread(_objectSpread({}, StyleSheet.absoluteFillObject), {}, {\n    alignItems: 'center'\n  }),\n  labelContainer: {\n    height: 16,\n    paddingBottom: 2\n  },\n  labelWrapper: _objectSpread({}, StyleSheet.absoluteFillObject),\n  label: _objectSpread({\n    fontSize: 12,\n    textAlign: 'center',\n    backgroundColor: 'transparent'\n  }, Platform.OS === 'web' ? {\n    whiteSpace: 'nowrap'\n  } : null),\n  badgeContainer: {\n    position: 'absolute',\n    left: 0,\n    top: -2\n  }\n});","map":null,"metadata":{},"sourceType":"module"}