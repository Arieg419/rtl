{"ast":null,"code":"import { LABEL_PADDING_HORIZONTAL, ADORNMENT_OFFSET, ADORNMENT_SIZE, FLAT_INPUT_OFFSET } from './constants';\nimport { AdornmentType, AdornmentSide } from './Adornment/enums';\nexport var calculateLabelTopPosition = function calculateLabelTopPosition(labelHeight) {\n  var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var optionalPadding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var customHeight = height > 0 ? height : 0;\n  return Math.floor((customHeight - labelHeight) / 2 + optionalPadding);\n};\nexport var calculateInputHeight = function calculateInputHeight(labelHeight) {\n  var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var minHeight = arguments.length > 2 ? arguments[2] : undefined;\n  var finalHeight = height > 0 ? height : labelHeight;\n  if (height > 0) return height;\n  return finalHeight < minHeight ? minHeight : finalHeight;\n};\nexport var calculatePadding = function calculatePadding(props) {\n  var height = props.height,\n      _props$multiline = props.multiline,\n      multiline = _props$multiline === void 0 ? false : _props$multiline;\n  var result = 0;\n\n  if (multiline) {\n    if (height && multiline) {\n      result = calculateTextAreaPadding(props);\n    } else {\n      result = calculateInputPadding(props);\n    }\n  }\n\n  return Math.max(0, result);\n};\n\nvar calculateTextAreaPadding = function calculateTextAreaPadding(props) {\n  var dense = props.dense;\n  return dense ? 10 : 20;\n};\n\nvar calculateInputPadding = function calculateInputPadding(_ref) {\n  var topPosition = _ref.topPosition,\n      fontSize = _ref.fontSize,\n      multiline = _ref.multiline,\n      scale = _ref.scale,\n      dense = _ref.dense,\n      offset = _ref.offset,\n      isAndroid = _ref.isAndroid;\n  var refFontSize = scale * fontSize;\n  var result = Math.floor(topPosition / 2);\n  result = result + Math.floor((refFontSize - fontSize) / 2) - (scale < 1 ? offset / 2 : 0);\n  if (multiline && isAndroid) result = Math.min(dense ? offset / 2 : offset, result);\n  return result;\n};\n\nexport var adjustPaddingOut = function adjustPaddingOut(_ref2) {\n  var pad = _ref2.pad,\n      multiline = _ref2.multiline,\n      label = _ref2.label,\n      scale = _ref2.scale,\n      height = _ref2.height,\n      fontSize = _ref2.fontSize,\n      dense = _ref2.dense,\n      offset = _ref2.offset,\n      isAndroid = _ref2.isAndroid;\n  var refFontSize = scale * fontSize;\n  var result = pad;\n\n  if (height) {\n    return {\n      paddingTop: Math.max(0, (height - fontSize) / 2),\n      paddingBottom: Math.max(0, (height - fontSize) / 2)\n    };\n  }\n\n  if (!isAndroid && multiline) {\n    if (dense) {\n      if (label) {\n        result += scale < 1 ? Math.min(offset, refFontSize / 2 * scale) : 0;\n      } else {\n        result += 0;\n      }\n    }\n\n    if (!dense) {\n      if (label) {\n        result += scale < 1 ? Math.min(offset, refFontSize * scale) : Math.min(offset / 2, refFontSize * scale);\n      } else {\n        result += scale < 1 ? Math.min(offset / 2, refFontSize * scale) : 0;\n      }\n    }\n\n    result = Math.floor(result);\n  }\n\n  return {\n    paddingTop: result,\n    paddingBottom: result\n  };\n};\nexport var adjustPaddingFlat = function adjustPaddingFlat(_ref3) {\n  var pad = _ref3.pad,\n      scale = _ref3.scale,\n      multiline = _ref3.multiline,\n      label = _ref3.label,\n      height = _ref3.height,\n      offset = _ref3.offset,\n      dense = _ref3.dense,\n      fontSize = _ref3.fontSize,\n      isAndroid = _ref3.isAndroid,\n      styles = _ref3.styles;\n  var result = pad;\n  var topResult = result;\n  var bottomResult = result;\n  var paddingTop = styles.paddingTop,\n      paddingBottom = styles.paddingBottom;\n  var refFontSize = scale * fontSize;\n\n  if (!multiline) {\n    // do not modify padding if input is not multiline\n    if (label) {\n      // return const style for flat input with label\n      return {\n        paddingTop: paddingTop,\n        paddingBottom: paddingBottom\n      };\n    } // return pad for flat input without label\n\n\n    return {\n      paddingTop: result,\n      paddingBottom: result\n    };\n  }\n\n  if (label) {\n    // add paddings passed from styles\n    topResult = paddingTop;\n    bottomResult = paddingBottom; // adjust top padding for iOS\n\n    if (!isAndroid) {\n      if (dense) {\n        topResult += scale < 1 ? Math.min(result, refFontSize * scale) - result / 2 : Math.min(result, refFontSize * scale) - result / 2;\n      }\n\n      if (!dense) {\n        topResult += scale < 1 ? Math.min(offset / 2, refFontSize * scale) : Math.min(result, refFontSize * scale) - offset / 2;\n      }\n    }\n\n    topResult = Math.floor(topResult);\n  } else {\n    if (height) {\n      // center text when height is passed\n      return {\n        paddingTop: Math.max(0, (height - fontSize) / 2),\n        paddingBottom: Math.max(0, (height - fontSize) / 2)\n      };\n    } // adjust paddings for iOS if no label\n\n\n    if (!isAndroid) {\n      if (dense) {\n        result += scale < 1 ? Math.min(offset / 2, fontSize / 2 * scale) : Math.min(offset / 2, scale);\n      }\n\n      if (!dense) {\n        result += scale < 1 ? Math.min(offset, fontSize * scale) : Math.min(fontSize, offset / 2 * scale);\n      }\n\n      result = Math.floor(result);\n      topResult = result;\n      bottomResult = result;\n    }\n  }\n\n  return {\n    paddingTop: Math.max(0, topResult),\n    paddingBottom: Math.max(0, bottomResult)\n  };\n};\nexport var interpolatePlaceholder = function interpolatePlaceholder(labeled, hasActiveOutline) {\n  return labeled.interpolate({\n    inputRange: [0, 1],\n    outputRange: [hasActiveOutline ? 0 : 1, 1]\n  });\n};\nexport function calculateFlatAffixTopPosition(_ref4) {\n  var height = _ref4.height,\n      paddingTop = _ref4.paddingTop,\n      paddingBottom = _ref4.paddingBottom,\n      affixHeight = _ref4.affixHeight;\n  var inputHeightWithoutPadding = height - paddingTop - paddingBottom;\n  var halfOfTheInputHeightDecreasedByAffixHeight = (inputHeightWithoutPadding - affixHeight) / 2;\n  return paddingTop + halfOfTheInputHeightDecreasedByAffixHeight;\n}\nexport function calculateOutlinedIconAndAffixTopPosition(_ref5) {\n  var height = _ref5.height,\n      affixHeight = _ref5.affixHeight,\n      labelYOffset = _ref5.labelYOffset;\n  return (height - affixHeight + labelYOffset) / 2;\n}\nexport var calculateFlatInputHorizontalPadding = function calculateFlatInputHorizontalPadding(_ref6) {\n  var adornmentConfig = _ref6.adornmentConfig;\n  var paddingLeft = LABEL_PADDING_HORIZONTAL;\n  var paddingRight = LABEL_PADDING_HORIZONTAL;\n  adornmentConfig.forEach(function (_ref7) {\n    var type = _ref7.type,\n        side = _ref7.side;\n\n    if (type === AdornmentType.Icon && side === AdornmentSide.Left) {\n      paddingLeft = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n    } else if (side === AdornmentSide.Right) {\n      if (type === AdornmentType.Affix) {\n        paddingRight = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n      } else if (type === AdornmentType.Icon) {\n        paddingRight = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n      }\n    }\n  });\n  return {\n    paddingLeft: paddingLeft,\n    paddingRight: paddingRight\n  };\n};","map":null,"metadata":{},"sourceType":"module"}