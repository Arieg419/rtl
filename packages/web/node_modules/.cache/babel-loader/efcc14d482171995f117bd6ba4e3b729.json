{"ast":null,"code":"function ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport React from 'react';\nimport { Animated, StyleSheet } from 'react-native';\nimport AnimatedText from '../../Typography/AnimatedText';\n\nvar InputLabel = function InputLabel(props) {\n  var parentState = props.parentState,\n      labelBackground = props.labelBackground;\n  var _props$labelProps = props.labelProps,\n      label = _props$labelProps.label,\n      error = _props$labelProps.error,\n      onLayoutAnimatedText = _props$labelProps.onLayoutAnimatedText,\n      hasActiveOutline = _props$labelProps.hasActiveOutline,\n      activeColor = _props$labelProps.activeColor,\n      placeholderStyle = _props$labelProps.placeholderStyle,\n      baseLabelTranslateX = _props$labelProps.baseLabelTranslateX,\n      baseLabelTranslateY = _props$labelProps.baseLabelTranslateY,\n      font = _props$labelProps.font,\n      fontSize = _props$labelProps.fontSize,\n      fontWeight = _props$labelProps.fontWeight,\n      placeholderOpacity = _props$labelProps.placeholderOpacity,\n      wiggleOffsetX = _props$labelProps.wiggleOffsetX,\n      labelScale = _props$labelProps.labelScale,\n      topPosition = _props$labelProps.topPosition,\n      paddingOffset = _props$labelProps.paddingOffset,\n      placeholderColor = _props$labelProps.placeholderColor,\n      errorColor = _props$labelProps.errorColor,\n      labelTranslationXOffset = _props$labelProps.labelTranslationXOffset;\n  var labelTranslationX = {\n    transform: [{\n      // Offset label scale since RN doesn't support transform origin\n      translateX: parentState.labeled.interpolate({\n        inputRange: [0, 1],\n        outputRange: [baseLabelTranslateX, labelTranslationXOffset || 0]\n      })\n    }]\n  };\n\n  var labelStyle = _objectSpread(_objectSpread({}, font), {}, {\n    fontSize: fontSize,\n    fontWeight: fontWeight,\n    transform: [{\n      // Wiggle the label when there's an error\n      translateX: parentState.error.interpolate({\n        inputRange: [0, 0.5, 1],\n        outputRange: [0, parentState.value && error ? wiggleOffsetX : 0, 0]\n      })\n    }, {\n      // Move label to top\n      translateY: parentState.labeled.interpolate({\n        inputRange: [0, 1],\n        outputRange: [baseLabelTranslateY, 0]\n      })\n    }, {\n      // Make label smaller\n      scale: parentState.labeled.interpolate({\n        inputRange: [0, 1],\n        outputRange: [labelScale, 1]\n      })\n    }]\n  });\n\n  return label ?\n  /*#__PURE__*/\n  // Position colored placeholder and gray placeholder on top of each other and crossfade them\n  // This gives the effect of animating the color, but allows us to use native driver\n  React.createElement(Animated.View, {\n    pointerEvents: \"none\",\n    style: [StyleSheet.absoluteFill, {\n      opacity: // Hide the label in minimized state until we measure it's width\n      parentState.value || parentState.focused ? parentState.labelLayout.measured ? 1 : 0 : 1\n    }, labelTranslationX]\n  }, labelBackground === null || labelBackground === void 0 ? void 0 : labelBackground({\n    parentState: parentState,\n    labelStyle: labelStyle,\n    labelProps: props.labelProps\n  }), /*#__PURE__*/React.createElement(AnimatedText, {\n    onLayout: onLayoutAnimatedText,\n    style: [placeholderStyle, {\n      top: topPosition\n    }, labelStyle, paddingOffset || {}, {\n      color: activeColor,\n      opacity: parentState.labeled.interpolate({\n        inputRange: [0, 1],\n        outputRange: [hasActiveOutline ? 1 : 0, 0]\n      })\n    }],\n    numberOfLines: 1\n  }, label), /*#__PURE__*/React.createElement(AnimatedText, {\n    style: [placeholderStyle, {\n      top: topPosition\n    }, labelStyle, paddingOffset, {\n      color: error && errorColor ? errorColor : placeholderColor,\n      opacity: placeholderOpacity\n    }],\n    numberOfLines: 1\n  }, label)) : null;\n};\n\nexport default InputLabel;","map":null,"metadata":{},"sourceType":"module"}