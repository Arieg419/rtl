{"ast":null,"code":"import _slicedToArray from \"/Users/omergoldberg/dev/rtl/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _regeneratorRuntime from \"/Users/omergoldberg/dev/rtl/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/omergoldberg/dev/rtl/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/omergoldberg/dev/rtl/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/omergoldberg/dev/rtl/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/Users/omergoldberg/dev/rtl/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Users/omergoldberg/dev/rtl/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"/Users/omergoldberg/dev/rtl/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/omergoldberg/dev/rtl/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport * as React from 'react';\nimport { Platform, StyleSheet, Animated, BackHandler, Dimensions, Easing, I18nManager, TouchableWithoutFeedback, View, ScrollView, findNodeHandle } from 'react-native';\nimport { withTheme } from '../../core/theming';\nimport Portal from '../Portal/Portal';\nimport Surface from '../Surface'; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\nimport MenuItem from './MenuItem';\nimport { APPROX_STATUSBAR_HEIGHT } from '../../constants'; // Minimum padding between the edge of the screen and the menu\n\nvar SCREEN_INDENT = 8; // From https://material.io/design/motion/speed.html#duration\n\nvar ANIMATION_DURATION = 250; // From the 'Standard easing' section of https://material.io/design/motion/speed.html#easing\n\nvar EASING = Easing.bezier(0.4, 0, 0.2, 1);\n/**\n * Menus display a list of choices on temporary elevated surfaces. Their placement varies based on the element that opens them.\n *\n *  <div class=\"screenshots\">\n *   <img class=\"medium\" src=\"screenshots/menu-1.png\" />\n *   <img class=\"medium\" src=\"screenshots/menu-2.png\" />\n * </div>\n *\n * ## Usage\n * ```js\n * import * as React from 'react';\n * import { View } from 'react-native';\n * import { Button, Menu, Divider, Provider } from 'react-native-paper';\n *\n * const MyComponent = () => {\n *   const [visible, setVisible] = React.useState(false);\n *\n *   const openMenu = () => setVisible(true);\n *\n *   const closeMenu = () => setVisible(false);\n *\n *   return (\n *     <Provider>\n *       <View\n *         style={{\n *           paddingTop: 50,\n *           flexDirection: 'row',\n *           justifyContent: 'center',\n *         }}>\n *         <Menu\n *           visible={visible}\n *           onDismiss={closeMenu}\n *           anchor={<Button onPress={openMenu}>Show menu</Button>}>\n *           <Menu.Item onPress={() => {}} title=\"Item 1\" />\n *           <Menu.Item onPress={() => {}} title=\"Item 2\" />\n *           <Divider />\n *           <Menu.Item onPress={() => {}} title=\"Item 3\" />\n *         </Menu>\n *       </View>\n *     </Provider>\n *   );\n * };\n *\n * export default MyComponent;\n * ```\n */\n\nvar Menu = /*#__PURE__*/function (_React$Component) {\n  _inherits(Menu, _React$Component);\n\n  var _super = _createSuper(Menu);\n\n  function Menu() {\n    var _this;\n\n    _classCallCheck(this, Menu);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"state\", {\n      rendered: _this.props.visible,\n      top: 0,\n      left: 0,\n      menuLayout: {\n        width: 0,\n        height: 0\n      },\n      anchorLayout: {\n        width: 0,\n        height: 0\n      },\n      opacityAnimation: new Animated.Value(0),\n      scaleAnimation: new Animated.ValueXY({\n        x: 0,\n        y: 0\n      })\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"anchor\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"menu\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"isAnchorCoord\", function () {\n      return ! /*#__PURE__*/React.isValidElement(_this.props.anchor);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"measureMenuLayout\", function () {\n      return new Promise(function (resolve) {\n        if (_this.menu) {\n          _this.menu.measureInWindow(function (x, y, width, height) {\n            resolve({\n              x: x,\n              y: y,\n              width: width,\n              height: height\n            });\n          });\n        }\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"measureAnchorLayout\", function () {\n      return new Promise(function (resolve) {\n        var anchor = _this.props.anchor;\n\n        if (_this.isAnchorCoord()) {\n          // @ts-ignore\n          resolve({\n            x: anchor.x,\n            y: anchor.y,\n            width: 0,\n            height: 0\n          });\n          return;\n        }\n\n        if (_this.anchor) {\n          _this.anchor.measureInWindow(function (x, y, width, height) {\n            resolve({\n              x: x,\n              y: y,\n              width: width,\n              height: height\n            });\n          });\n        }\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"updateVisibility\", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return Promise.resolve();\n\n            case 2:\n              if (_this.props.visible) {\n                _this.show();\n              } else {\n                _this.hide();\n              }\n\n            case 3:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    })));\n\n    _defineProperty(_assertThisInitialized(_this), \"isBrowser\", function () {\n      return Platform.OS === 'web' && 'document' in global;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"focusFirstDOMNode\", function (el) {\n      if (el && _this.isBrowser()) {\n        // When in the browser, we want to focus the first focusable item on toggle\n        // For example, when menu is shown, focus the first item in the menu\n        // And when menu is dismissed, send focus back to the button to resume tabbing\n        var node = findNodeHandle(el);\n        var focusableNode = node.querySelector( // This is a rough list of selectors that can be focused\n        'button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])');\n        focusableNode === null || focusableNode === void 0 ? void 0 : focusableNode.focus();\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleDismiss\", function () {\n      if (_this.props.visible) {\n        _this.props.onDismiss();\n      }\n\n      return true;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleKeypress\", function (e) {\n      if (e.key === 'Escape') {\n        _this.props.onDismiss();\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"attachListeners\", function () {\n      BackHandler.addEventListener('hardwareBackPress', _this.handleDismiss);\n      Dimensions.addEventListener('change', _this.handleDismiss);\n      _this.isBrowser() && document.addEventListener('keyup', _this.handleKeypress);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"removeListeners\", function () {\n      BackHandler.removeEventListener('hardwareBackPress', _this.handleDismiss);\n      Dimensions.removeEventListener('change', _this.handleDismiss);\n      _this.isBrowser() && document.removeEventListener('keyup', _this.handleKeypress);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"show\", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n      var windowLayout, _yield$Promise$all, _yield$Promise$all2, menuLayout, anchorLayout;\n\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              windowLayout = Dimensions.get('window');\n              _context2.next = 3;\n              return Promise.all([_this.measureMenuLayout(), _this.measureAnchorLayout()]);\n\n            case 3:\n              _yield$Promise$all = _context2.sent;\n              _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n              menuLayout = _yield$Promise$all2[0];\n              anchorLayout = _yield$Promise$all2[1];\n\n              if (!(!windowLayout.width || !windowLayout.height || !menuLayout.width || !menuLayout.height || !anchorLayout.width && !_this.isAnchorCoord() || !anchorLayout.height && !_this.isAnchorCoord())) {\n                _context2.next = 10;\n                break;\n              }\n\n              requestAnimationFrame(_this.show);\n              return _context2.abrupt(\"return\");\n\n            case 10:\n              _this.setState(function () {\n                return {\n                  left: anchorLayout.x,\n                  top: anchorLayout.y,\n                  anchorLayout: {\n                    height: anchorLayout.height,\n                    width: anchorLayout.width\n                  },\n                  menuLayout: {\n                    width: menuLayout.width,\n                    height: menuLayout.height\n                  }\n                };\n              }, function () {\n                _this.attachListeners();\n\n                var animation = _this.props.theme.animation;\n                Animated.parallel([Animated.timing(_this.state.scaleAnimation, {\n                  toValue: {\n                    x: menuLayout.width,\n                    y: menuLayout.height\n                  },\n                  duration: ANIMATION_DURATION * animation.scale,\n                  easing: EASING,\n                  useNativeDriver: true\n                }), Animated.timing(_this.state.opacityAnimation, {\n                  toValue: 1,\n                  duration: ANIMATION_DURATION * animation.scale,\n                  easing: EASING,\n                  useNativeDriver: true\n                })]).start(function (_ref5) {\n                  var finished = _ref5.finished;\n\n                  if (finished) {\n                    _this.focusFirstDOMNode(_this.menu);\n                  }\n                });\n              });\n\n            case 11:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    })));\n\n    _defineProperty(_assertThisInitialized(_this), \"hide\", function () {\n      _this.removeListeners();\n\n      var animation = _this.props.theme.animation;\n      Animated.timing(_this.state.opacityAnimation, {\n        toValue: 0,\n        duration: ANIMATION_DURATION * animation.scale,\n        easing: EASING,\n        useNativeDriver: true\n      }).start(function (_ref6) {\n        var finished = _ref6.finished;\n\n        if (finished) {\n          _this.setState({\n            menuLayout: {\n              width: 0,\n              height: 0\n            },\n            rendered: false\n          });\n\n          _this.state.scaleAnimation.setValue({\n            x: 0,\n            y: 0\n          });\n\n          _this.focusFirstDOMNode(_this.anchor);\n        }\n      });\n    });\n\n    return _this;\n  }\n\n  _createClass(Menu, [{\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      if (prevProps.visible !== this.props.visible) {\n        this.updateVisibility();\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.removeListeners();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$props = this.props,\n          visible = _this$props.visible,\n          anchor = _this$props.anchor,\n          contentStyle = _this$props.contentStyle,\n          style = _this$props.style,\n          children = _this$props.children,\n          theme = _this$props.theme,\n          statusBarHeight = _this$props.statusBarHeight,\n          onDismiss = _this$props.onDismiss,\n          overlayAccessibilityLabel = _this$props.overlayAccessibilityLabel;\n      var _this$state = this.state,\n          rendered = _this$state.rendered,\n          menuLayout = _this$state.menuLayout,\n          anchorLayout = _this$state.anchorLayout,\n          opacityAnimation = _this$state.opacityAnimation,\n          scaleAnimation = _this$state.scaleAnimation;\n      var _this$state2 = this.state,\n          left = _this$state2.left,\n          top = _this$state2.top; // I don't know why but on Android measure function is wrong by 24\n\n      var additionalVerticalValue = Platform.select({\n        android: statusBarHeight,\n        default: 0\n      });\n      var scaleTransforms = [{\n        scaleX: scaleAnimation.x.interpolate({\n          inputRange: [0, menuLayout.width],\n          outputRange: [0, 1]\n        })\n      }, {\n        scaleY: scaleAnimation.y.interpolate({\n          inputRange: [0, menuLayout.height],\n          outputRange: [0, 1]\n        })\n      }];\n      var windowLayout = Dimensions.get('window'); // We need to translate menu while animating scale to imitate transform origin for scale animation\n\n      var positionTransforms = []; // Check if menu fits horizontally and if not align it to right.\n\n      if (left <= windowLayout.width - menuLayout.width - SCREEN_INDENT) {\n        positionTransforms.push({\n          translateX: scaleAnimation.x.interpolate({\n            inputRange: [0, menuLayout.width],\n            outputRange: [-(menuLayout.width / 2), 0]\n          })\n        }); // Check if menu position has enough space from left side\n\n        if (left < SCREEN_INDENT) {\n          left = SCREEN_INDENT;\n        }\n      } else {\n        positionTransforms.push({\n          translateX: scaleAnimation.x.interpolate({\n            inputRange: [0, menuLayout.width],\n            outputRange: [menuLayout.width / 2, 0]\n          })\n        });\n        left += anchorLayout.width - menuLayout.width;\n        var right = left + menuLayout.width; // Check if menu position has enough space from right side\n\n        if (right > windowLayout.width - SCREEN_INDENT) {\n          left = windowLayout.width - SCREEN_INDENT - menuLayout.width;\n        }\n      } // If the menu is larger than available vertical space,\n      // calculate the height of scrollable view\n\n\n      var scrollableMenuHeight = 0; // Check if the menu should be scrollable\n\n      if ( // Check if the menu overflows from bottom side\n      top >= windowLayout.height - menuLayout.height - SCREEN_INDENT - additionalVerticalValue && // And bottom side of the screen has more space than top side\n      top <= windowLayout.height - top) {\n        // Scrollable menu should be below the anchor (expands downwards)\n        scrollableMenuHeight = windowLayout.height - top - SCREEN_INDENT - additionalVerticalValue;\n      } else if ( // Check if the menu overflows from bottom side\n      top >= windowLayout.height - menuLayout.height - SCREEN_INDENT - additionalVerticalValue && // And top side of the screen has more space than bottom side\n      top >= windowLayout.height - top && // And menu overflows from top side\n      top <= menuLayout.height - anchorLayout.height + SCREEN_INDENT - additionalVerticalValue) {\n        // Scrollable menu should be above the anchor (expands upwards)\n        scrollableMenuHeight = top + anchorLayout.height - SCREEN_INDENT + additionalVerticalValue;\n      } // Scrollable menu max height\n\n\n      scrollableMenuHeight = scrollableMenuHeight > windowLayout.height - 2 * SCREEN_INDENT ? windowLayout.height - 2 * SCREEN_INDENT : scrollableMenuHeight; // Menu is typically positioned below the element that generates it\n      // So first check if it fits below the anchor (expands downwards)\n\n      if ( // Check if menu fits vertically\n      top <= windowLayout.height - menuLayout.height - SCREEN_INDENT - additionalVerticalValue || // Or if the menu overflows from bottom side\n      top >= windowLayout.height - menuLayout.height - SCREEN_INDENT - additionalVerticalValue && // And bottom side of the screen has more space than top side\n      top <= windowLayout.height - top) {\n        positionTransforms.push({\n          translateY: scaleAnimation.y.interpolate({\n            inputRange: [0, menuLayout.height],\n            outputRange: [-((scrollableMenuHeight || menuLayout.height) / 2), 0]\n          })\n        }); // Check if menu position has enough space from top side\n\n        if (top < SCREEN_INDENT) {\n          top = SCREEN_INDENT;\n        }\n      } else {\n        positionTransforms.push({\n          translateY: scaleAnimation.y.interpolate({\n            inputRange: [0, menuLayout.height],\n            outputRange: [(scrollableMenuHeight || menuLayout.height) / 2, 0]\n          })\n        });\n        top += anchorLayout.height - (scrollableMenuHeight || menuLayout.height);\n        var bottom = top + (scrollableMenuHeight || menuLayout.height) + additionalVerticalValue; // Check if menu position has enough space from bottom side\n\n        if (bottom > windowLayout.height - SCREEN_INDENT) {\n          top = scrollableMenuHeight === windowLayout.height - 2 * SCREEN_INDENT ? -SCREEN_INDENT * 2 : windowLayout.height - menuLayout.height - SCREEN_INDENT - additionalVerticalValue;\n        }\n      }\n\n      var shadowMenuContainerStyle = _objectSpread({\n        opacity: opacityAnimation,\n        transform: scaleTransforms,\n        borderRadius: theme.roundness\n      }, scrollableMenuHeight ? {\n        height: scrollableMenuHeight\n      } : {});\n\n      var positionStyle = _objectSpread({\n        top: this.isAnchorCoord() ? top : top + additionalVerticalValue\n      }, I18nManager.isRTL ? {\n        right: left\n      } : {\n        left: left\n      });\n\n      return /*#__PURE__*/React.createElement(View, {\n        ref: function ref(_ref2) {\n          _this2.anchor = _ref2;\n        },\n        collapsable: false\n      }, this.isAnchorCoord() ? null : anchor, rendered ? /*#__PURE__*/React.createElement(Portal, null, /*#__PURE__*/React.createElement(TouchableWithoutFeedback, {\n        accessibilityLabel: overlayAccessibilityLabel,\n        accessibilityRole: \"button\",\n        onPress: onDismiss\n      }, /*#__PURE__*/React.createElement(View, {\n        style: StyleSheet.absoluteFill\n      })), /*#__PURE__*/React.createElement(View, {\n        ref: function ref(_ref) {\n          _this2.menu = _ref;\n        },\n        collapsable: false,\n        accessibilityViewIsModal: visible,\n        style: [styles.wrapper, positionStyle, style],\n        pointerEvents: visible ? 'box-none' : 'none' // @ts-ignore - FIX ME\n        ,\n        onAccessibilityEscape: onDismiss\n      }, /*#__PURE__*/React.createElement(Animated.View, {\n        style: {\n          transform: positionTransforms\n        }\n      }, /*#__PURE__*/React.createElement(Surface, {\n        style: [styles.shadowMenuContainer, shadowMenuContainerStyle, contentStyle]\n      }, scrollableMenuHeight && /*#__PURE__*/React.createElement(ScrollView, null, children) || /*#__PURE__*/React.createElement(React.Fragment, null, children))))) : null);\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      if (nextProps.visible && !prevState.rendered) {\n        return {\n          rendered: true\n        };\n      }\n\n      return null;\n    }\n  }]);\n\n  return Menu;\n}(React.Component);\n\n_defineProperty(Menu, \"Item\", MenuItem);\n\n_defineProperty(Menu, \"defaultProps\", {\n  statusBarHeight: APPROX_STATUSBAR_HEIGHT,\n  overlayAccessibilityLabel: 'Close menu'\n});\n\nvar styles = StyleSheet.create({\n  wrapper: {\n    position: 'absolute'\n  },\n  shadowMenuContainer: {\n    opacity: 0,\n    paddingVertical: 8,\n    elevation: 8\n  }\n});\nexport default withTheme(Menu);","map":null,"metadata":{},"sourceType":"module"}